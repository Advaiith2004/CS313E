"""
Student information for this assignment:

Replace <Advaiith Pathi> with your name.
On my/our honor, <Advaiith Pathi> and <Vinay Majjiga>, this
programming assignment is my own work and I have not provided this code to
any other student.

I have read and understand the course syllabus's guidelines regarding Academic
Integrity. I understand that if I violate the Academic Integrity policy (e.g.
copy code from someone else, have the code generated by an LLM, or give my
code to someone else), the case shall be submitted to the Office of the Dean of
Students. Academic penalties up to and including an F in the course are likely.

UT EID 1: ap64999
UT EID 2: Vrm724
"""

import sys

STEP_SIZE_CONSTANT = 3

def is_prime(n):
    """
    Determines if a number is prime.

    pre: n is a positive integer.
    post: Returns True if n is prime, otherwise returns False.
    """
    if n == 1:
        return False

    limit = int(n**0.5) + 1
    div = 2
    while div < limit:
        if n % div == 0:
            return False
        div += 1
    return True

def hash_word(s, size):
    """
    Hashes a lowercase string to an index in a hash table.

    pre: s is a lowercase string, and size is a positive integer representing either
         hash table size or the constant for double hashing.
    post: Returns an integer index in the range [0, size - 1] where the string hashes to.
    """
    hash_idx = 0
    for c in s:
        letter = ord(c) - 96
        hash_idx = (hash_idx * 26 + letter) % size
    return hash_idx

def step_size(s):
    """
    Calculates step size for double hashing using STEP_SIZE_CONSTANT.

    pre: s is a lowercase string.
    post: Returns the calculated step size as an integer based on the provided string.
    """
    key_value = hash_word(s,STEP_SIZE_CONSTANT)
    size = STEP_SIZE_CONSTANT - (key_value % STEP_SIZE_CONSTANT)
    return size

def insert_word(s, hash_table):
    """
    Inserts a string into the hash table using double hashing for collision resolution.
    No duplicates are allowed.

    pre: s is a string, and hash_table is a list representing the hash table.
    post: Inserts s into hash_table at the correct index; resolves any collisions
          by double hashing.
    """
    size = step_size(s)
    table_size = len(hash_table)
    index = hash_word(s, len(hash_table))
    og_index = index
    if hash_table[index] == s:
        return
    else:
        while hash_table[index] != '':
            index = (index + size) % table_size
            if hash_table[index] == s:
                return
            elif index == og_index:
                break
    if hash_table[index] == '':
        hash_table[index] = s
    else:
        og_index = index
        while hash_table[index] != '':
            index = (index + size) % table_size
            if hash_table[index] == '':
                hash_table[index] = s
                break
            elif index == og_index:
                break

def find_word(s, hash_table):
    """
    Searches for a string in the hash table.
    Note: using the `in` operator is incorrect as that will be O(N). We want
          an O(1) time average time complexity using hashing.

    pre: s is a string, and hash_table is a list representing the hash table.
    post: Returns True if s is found in hash_table, otherwise returns False.
    """
    index = hash_word(s, len(hash_table))
    size = step_size(s)
    table_size = len(hash_table)
    if hash_table[index] == s:
        return True
    else:
        og_index = index
        while hash_table[index] != "":
            if hash_table[index] == s:
                return True
            index = (index + size) % table_size
            if index == og_index:
                break
    return False
def is_reducible(s, hash_table, hash_memo):
    """
    #Using a string, a hash table, and a hash_memo, recursively "
    #find if the string is reducible. If the string is reducible, "
    #it is entered into the hash memo and returns True. Otherwise,"
    #it returns False.
    """
    if not find_word(s, hash_table):
        return False
    if find_word(s, hash_memo):
        return True
    if len(s) == 1:
        if s == "a" or s== "i" or s== "o":
            return True
        return False
    for i in range(len(s)):
        reduced = s[:i] + s[i+1:]
        if is_reducible(reduced, hash_table, hash_memo):
            insert_word(s, hash_memo)
            return True

    return False


def get_longest_words(string_list):
    """
    Finds longest words from a list.

    pre: string_list is a list of lowercase strings.
    post: Returns a list of words in string_list that have the maximum length.
    """
    len_dict = {}
    str_lst = []
    if string_list == []:
        return []
    for word in string_list:
        if len(word) in len_dict:
            len_dict[len(word)] += [word]
        else:
            len_dict[len(word)] = [word]
    for value in len_dict[max(len_dict.keys())]:
        str_lst.append(value)
    return str_lst


def main():
    """The main function that calculates the longest reducible words"""

    word_lst = []
    for line in sys.stdin:
        word = line.strip()
        if word == "":
            break
        if word.isalpha():
            word_lst.append(word)

    len_word_lst = len(word_lst)
    n = 2 * len_word_lst + 1
    while not is_prime(n):
        n += 1
    hash_lst = []
    for _ in range(n):
        hash_lst.append("")
    for word in word_lst:
        insert_word(word, hash_lst)

    m = int(0.2 * len_word_lst) + 1
    while not is_prime(m):
        m += 1
    hash_memo = []
    for _ in range(m):
        hash_memo.append("")

    reducible_lst = []
    for word in word_lst:
        if is_reducible(word, hash_lst, hash_memo):
            reducible_lst.append(word)

    longest_words = get_longest_words(reducible_lst)
    for word in sorted(longest_words):
        print(word)

if __name__ == "__main__":
    main()
